name: Perimetre - Deployment Success

# Monitors Cloudflare Workers deployments and sends Slack notification on successful deployment.
#
# Setup:
# 1. Add secrets in GitHub organization or repo settings (Settings → Secrets and variables → Actions):
#    CLOUDFLARE_API_TOKEN - API token with "Workers Scripts: Read" permission
#    CLOUDFLARE_ACCOUNT_ID - Your Cloudflare account ID
#    SLACK_BOT_TOKEN - Slack bot OAuth token (starts with xoxb-)
# 2. Add variables in GitHub organization or repo settings (Variables tab):
#    CLOUDFLARE_WORKER_NAME - Cloudflare Worker script name
#    SLACK_CHANNEL_ID - Slack channel ID for notifications
#
# Note: This workflow monitors Workers deployments via the Workers API.
# Deployments are matched by timestamp (new deployment created after workflow start).

on:
  workflow_call:
    inputs:
      cloudflare_worker_name:
        description: 'Cloudflare Worker script name'
        required: true
        type: string
      slack_channel_id:
        description: 'Slack channel ID where notifications will be sent'
        required: true
        type: string
      poll_interval_ms:
        description: 'Polling interval in milliseconds'
        required: false
        type: number
        default: 10000
      max_attempts:
        description: 'Maximum number of polling attempts'
        required: false
        type: number
        default: 120
    secrets:
      cloudflare_api_token:
        description: 'Cloudflare API token with Workers Scripts: Read permission'
        required: true
      cloudflare_account_id:
        description: 'Cloudflare account ID'
        required: true
      slack_bot_token:
        description: 'Slack bot token'
        required: true

jobs:
  check-deployment:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for successful deployment
        id: check
        uses: actions/github-script@v8
        env:
          CF_API_TOKEN: ${{ secrets.cloudflare_api_token }}
          CF_ACCOUNT_ID: ${{ secrets.cloudflare_account_id }}
          CF_WORKER_NAME: ${{ inputs.cloudflare_worker_name }}
          COMMIT_SHA: ${{ github.sha }}
          POLL_INTERVAL_MS: ${{ inputs.poll_interval_ms }}
          MAX_ATTEMPTS: ${{ inputs.max_attempts }}
        with:
          script: |
            const cfApiToken = process.env.CF_API_TOKEN;
            const cfAccountId = process.env.CF_ACCOUNT_ID;
            const cfWorkerName = process.env.CF_WORKER_NAME;
            const commitSha = process.env.COMMIT_SHA;
            const pollInterval = parseInt(process.env.POLL_INTERVAL_MS) || 10000;
            const maxAttempts = parseInt(process.env.MAX_ATTEMPTS) || 120;

            if (!cfApiToken || !cfAccountId || !cfWorkerName) {
              core.setFailed('Missing required secrets/variables');
              return;
            }

            core.info(`Monitoring Cloudflare Workers deployment for ${cfWorkerName} (commit ${commitSha.substring(0, 7)})`);

            const headers = {
              'Authorization': `Bearer ${cfApiToken}`,
              'Content-Type': 'application/json'
            };

            // Record workflow start time (used to detect new deployments)
            const workflowStartTime = new Date();
            core.info(`Workflow started at: ${workflowStartTime.toISOString()}`);

            let attempts = 0;
            let lastDeploymentId = null;

            while (attempts < maxAttempts) {
              attempts++;

              try {
                const response = await fetch(
                  `https://api.cloudflare.com/client/v4/accounts/${cfAccountId}/workers/scripts/${cfWorkerName}/deployments`,
                  { headers }
                );

                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();
                const deployments = data.result?.deployments || [];

                if (deployments.length === 0) {
                  core.info(`[${attempts}/${maxAttempts}] No deployments found yet...`);
                  await new Promise(resolve => setTimeout(resolve, pollInterval));
                  continue;
                }

                // Latest deployment is first in the array
                const latestDeployment = deployments[0];
                const deploymentTime = new Date(latestDeployment.created_on);

                core.info(`Latest deployment: ${latestDeployment.id}`);
                core.info(`  Created: ${latestDeployment.created_on}`);
                core.info(`  Source: ${latestDeployment.source}`);
                core.info(`  Author: ${latestDeployment.author_email}`);

                // Check if this is a new deployment (created after workflow started)
                // We add a 30-second buffer to account for timing differences
                const bufferMs = 30000;
                const isNewDeployment = deploymentTime >= new Date(workflowStartTime.getTime() - bufferMs);

                if (isNewDeployment) {
                  core.info('✅ New deployment detected!');

                  // Get worker URL (Workers don't have deployment-specific URLs in the API)
                  // The URL would be https://{worker-name}.{subdomain}.workers.dev
                  // But we can't determine the subdomain from the API, so we'll just use the deployment ID
                  const workerUrl = `https://dash.cloudflare.com/${cfAccountId}/workers/services/view/${cfWorkerName}/production`;

                  core.setOutput('deployment_url', workerUrl);
                  core.setOutput('deployment_id', latestDeployment.id);
                  core.setOutput('deployment_time', latestDeployment.created_on);
                  return;
                }

                core.info(`[${attempts}/${maxAttempts}] Waiting for new deployment (current deployment from ${latestDeployment.created_on})...`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));

              } catch (error) {
                core.error(`Error fetching deployments: ${error.message}`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
              }
            }

            core.info('Max attempts reached, no new deployment detected');

      - name: Send success notification to Slack
        if: steps.check.outputs.deployment_url
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.slack_bot_token }}
          payload: |
            channel: ${{ inputs.slack_channel_id }}
            text: "Deployment successful for ${{ github.repository }}"
            blocks:
              - type: header
                text:
                  type: plain_text
                  text: "Deployment Successful"
                  emoji: true
              - type: section
                fields:
                  - type: mrkdwn
                    text: "*Repository:*\n<${{ github.event.repository.html_url }}|${{ github.repository }}>"
                  - type: mrkdwn
                    text: "*Branch:*\n${{ github.ref_name }}"
                  - type: mrkdwn
                    text: "*Commit:*\n<${{ github.event.head_commit.url }}|`${{ github.sha }}`>"
                  - type: mrkdwn
                    text: "*Author:*\n${{ github.event.head_commit.author.name }}"
                  - type: mrkdwn
                    text: "*URL:*\n<${{ steps.check.outputs.deployment_url }}|View Deployment>"
              - type: section
                text:
                  type: mrkdwn
                  text: "*Commit Message:*\n```${{ github.event.head_commit.message }}```"
