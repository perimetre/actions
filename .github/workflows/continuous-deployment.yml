name: Perimetre - Deployment Notifications

# Monitors Cloudflare Workers deployments and sends Slack notifications.
#
# Setup:
# 1. Add secrets in GitHub organization or repo settings (Settings ‚Üí Secrets and variables ‚Üí Actions):
#    CLOUDFLARE_API_TOKEN - API token with "Workers Scripts: Read" permission
#    CLOUDFLARE_ACCOUNT_ID - Your Cloudflare account ID
#    SLACK_BOT_TOKEN - Slack bot OAuth token (starts with xoxb-)
# 2. Add variables in GitHub organization or repo settings (Variables tab):
#    CLOUDFLARE_WORKER_NAME - Cloudflare Worker script name
#    SLACK_CHANNEL_ID - Slack channel ID for notifications
#
# Note: This workflow monitors deployments via Cloudflare's API with smart detection.

on:
  workflow_call:
    inputs:
      cloudflare_worker_name:
        description: 'Cloudflare Worker script name'
        required: true
        type: string
      slack_channel_id:
        description: 'Slack channel ID where notifications will be sent'
        required: true
        type: string
      poll_interval_seconds:
        description: 'Polling interval in seconds'
        required: false
        type: number
        default: 5
      max_wait_minutes:
        description: 'Maximum time to wait for deployment (in minutes)'
        required: false
        type: number
        default: 5
    secrets:
      cloudflare_api_token:
        description: 'Cloudflare API token with Workers Scripts: Read permission'
        required: true
      cloudflare_account_id:
        description: 'Cloudflare account ID'
        required: true
      slack_bot_token:
        description: 'Slack bot token'
        required: true

jobs:
  check-deployment:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for Cloudflare deployment
        id: check
        uses: actions/github-script@v8
        env:
          CF_API_TOKEN: ${{ secrets.cloudflare_api_token }}
          CF_ACCOUNT_ID: ${{ secrets.cloudflare_account_id }}
          CF_WORKER_NAME: ${{ inputs.cloudflare_worker_name }}
          COMMIT_SHA: ${{ github.sha }}
          POLL_INTERVAL_SECONDS: ${{ inputs.poll_interval_seconds }}
          MAX_WAIT_MINUTES: ${{ inputs.max_wait_minutes }}
        with:
          script: |
            const cfApiToken = process.env.CF_API_TOKEN;
            const cfAccountId = process.env.CF_ACCOUNT_ID;
            const cfWorkerName = process.env.CF_WORKER_NAME;
            const commitSha = process.env.COMMIT_SHA;
            const pollIntervalSeconds = parseInt(process.env.POLL_INTERVAL_SECONDS) || 5;
            const maxWaitMinutes = parseInt(process.env.MAX_WAIT_MINUTES) || 5;

            const pollIntervalMs = pollIntervalSeconds * 1000;
            const maxAttempts = Math.ceil((maxWaitMinutes * 60) / pollIntervalSeconds);

            if (!cfApiToken || !cfAccountId || !cfWorkerName) {
              core.setFailed('Missing required secrets/variables');
              return;
            }

            core.info(`Monitoring deployment for ${cfWorkerName} (commit ${commitSha.substring(0, 7)})`);
            core.info(`Config: ${pollIntervalSeconds}s interval, ${maxWaitMinutes}min max wait, ${maxAttempts} max attempts`);

            const headers = {
              'Authorization': `Bearer ${cfApiToken}`,
              'Content-Type': 'application/json'
            };

            const workflowStartTime = new Date();
            let initialDeploymentId = null;
            let attempts = 0;

            // Helper function to fetch latest version (for GitHub integration deployments)
            const fetchLatestVersion = async () => {
              const response = await fetch(
                `https://api.cloudflare.com/client/v4/accounts/${cfAccountId}/workers/scripts/${cfWorkerName}/versions`,
                { headers }
              );

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error: ${response.status} - ${errorText}`);
              }

              const data = await response.json();
              return data.result?.items?.[0]; // Latest version is first
            };

            try {
              // Get initial version ID to compare against
              core.info('Fetching current version...');
              const initialVersion = await fetchLatestVersion();

              if (initialVersion) {
                initialDeploymentId = initialVersion.id;
                const versionTime = new Date(initialVersion.metadata.created_on);
                const ageSeconds = (workflowStartTime - versionTime) / 1000;

                core.info(`Current version: #${initialVersion.number} (${initialVersion.id})`);
                core.info(`  Created: ${initialVersion.metadata.created_on} (${ageSeconds.toFixed(0)}s ago)`);
                core.info(`  Source: ${initialVersion.metadata.source}`);
                core.info(`  Author: ${initialVersion.metadata.author_email}`);
                core.info(`  Alias: ${initialVersion.annotations['workers/alias'] || 'none'}`);

                // If version is VERY fresh (< 30 seconds), it might be ours
                // Check once after a short delay to see if it's still the latest
                if (ageSeconds < 30) {
                  core.info(`Version is very fresh (${ageSeconds.toFixed(0)}s old), waiting 10s to confirm...`);
                  await new Promise(resolve => setTimeout(resolve, 10000));

                  const checkVersion = await fetchLatestVersion();
                  if (checkVersion && checkVersion.id === initialDeploymentId) {
                    // Same version after 10s, likely ours
                    const newAge = (new Date() - versionTime) / 1000;
                    core.info(`‚úÖ Version confirmed after 10s (now ${newAge.toFixed(0)}s old) - assuming this is the current push`);
                    // Link to specific version in dashboard (shows build logs and details)
                    const versionUrl = `https://dash.cloudflare.com/${cfAccountId}/workers/services/view/${cfWorkerName}/production/versions/${initialVersion.id}`;
                    core.setOutput('deployment_status', 'success');
                    core.setOutput('deployment_url', versionUrl);
                    core.setOutput('deployment_id', initialVersion.id);
                    core.setOutput('deployment_time', initialVersion.metadata.created_on);
                    core.setOutput('version_number', initialVersion.number);
                    return;
                  } else {
                    core.info('Version changed during wait, continuing to poll...');
                    if (checkVersion) {
                      initialDeploymentId = checkVersion.id;
                    }
                  }
                }
              } else {
                core.info('No existing versions found');
              }

              // Poll for new version
              core.info('Polling for new version...');

              while (attempts < maxAttempts) {
                attempts++;
                await new Promise(resolve => setTimeout(resolve, pollIntervalMs));

                const latestVersion = await fetchLatestVersion();

                if (!latestVersion) {
                  core.info(`[${attempts}/${maxAttempts}] No versions found`);
                  continue;
                }

                // Check if this is a new version (different ID)
                if (latestVersion.id !== initialDeploymentId) {
                  core.info(`‚úÖ New version detected!`);
                  core.info(`  Version: #${latestVersion.number}`);
                  core.info(`  ID: ${latestVersion.id}`);
                  core.info(`  Created: ${latestVersion.metadata.created_on}`);
                  core.info(`  Source: ${latestVersion.metadata.source}`);
                  core.info(`  Author: ${latestVersion.metadata.author_email}`);
                  core.info(`  Alias: ${latestVersion.annotations['workers/alias'] || 'none'}`);

                  // Link to specific version in dashboard (shows build logs and details)
                  const versionUrl = `https://dash.cloudflare.com/${cfAccountId}/workers/services/view/${cfWorkerName}/production/versions/${latestVersion.id}`;
                  core.setOutput('deployment_status', 'success');
                  core.setOutput('deployment_url', versionUrl);
                  core.setOutput('deployment_id', latestVersion.id);
                  core.setOutput('deployment_time', latestVersion.metadata.created_on);
                  core.setOutput('version_number', latestVersion.number);
                  return;
                }

                core.info(`[${attempts}/${maxAttempts}] Still waiting (current: v${latestVersion.number})...`);
              }

              // Timeout reached
              core.warning(`‚ö†Ô∏è No new version detected after ${maxWaitMinutes} minutes`);
              core.warning('This might mean:');
              core.warning('  1. Build is still in progress (increase max_wait_minutes)');
              core.warning('  2. Build failed before completing');
              core.warning('  3. No build was triggered for this push');

              // Link to builds page where they can see failed builds
              const buildsUrl = `https://dash.cloudflare.com/${cfAccountId}/workers/services/view/${cfWorkerName}/production/deployments`;
              core.setOutput('deployment_status', 'timeout');
              core.setOutput('builds_url', buildsUrl);

            } catch (error) {
              core.error(`‚ùå Error: ${error.message}`);
              const buildsUrl = `https://dash.cloudflare.com/${cfAccountId}/workers/services/view/${cfWorkerName}/production/deployments`;
              core.setOutput('deployment_status', 'error');
              core.setOutput('error_message', error.message);
              core.setOutput('builds_url', buildsUrl);
              throw error;
            }

      - name: Send success notification to Slack
        if: steps.check.outputs.deployment_status == 'success'
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.slack_bot_token }}
          payload: |
            channel: ${{ inputs.slack_channel_id }}
            text: "‚úÖ Deployed v${{ steps.check.outputs.version_number }}: ${{ github.event.head_commit.message }}"
            blocks:
              - type: section
                text:
                  type: mrkdwn
                  text: "‚úÖ *<${{ steps.check.outputs.deployment_url }}|Deployed>*${{ github.event.head_commit.message && format('\n{0}', github.event.head_commit.message) || '' }}"
              - type: context
                elements:
                  - type: mrkdwn
                    text: "<${{ github.event.head_commit.url }}|${{ github.repository }}> ‚Ä¢ v${{ steps.check.outputs.version_number }} ‚Ä¢ ${{ github.event.head_commit.author.name }} ‚Ä¢ `${{ github.ref_name }}`"

      - name: Send timeout/failure notification to Slack
        if: always() && (steps.check.outputs.deployment_status == 'timeout' || steps.check.outputs.deployment_status == 'error')
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.slack_bot_token }}
          payload: |
            channel: ${{ inputs.slack_channel_id }}
            text: "üü• Build timeout: ${{ github.event.head_commit.message }}"
            blocks:
              - type: section
                text:
                  type: mrkdwn
                  text: "üü• *<${{ steps.check.outputs.builds_url }}|Build Timeout>*${{ github.event.head_commit.message && format('\n{0}', github.event.head_commit.message) || '' }}"
              - type: context
                elements:
                  - type: mrkdwn
                    text: "<${{ github.event.head_commit.url }}|${{ github.repository }}> ‚Ä¢ ${{ github.event.head_commit.author.name }} ‚Ä¢ `${{ github.ref_name }}` ‚Ä¢ Check build logs"
